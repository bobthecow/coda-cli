#!/usr/bin/python
#
# @todo figure out why `echo 'foo' | coda | xargs echo` works but `echo 'foo' | coda | echo` doesn't.

import sys, os, time, commands, optparse
from tempfile import mkstemp
from pipes import quote

version = '0.99.0'
bundle_id = 'com.panic.Coda'

parser = optparse.OptionParser(
    usage='usage: %prog [options] [file ...]',
    epilog="To read input from stdin, pass `-` for [file]. If used in a pipe, coda discards all options and implies `-w`."
)
opts = (
    ('-w', '--wait', {'action': 'store_true', 'default': False, 'help': 'wait for file to be closed'}),
    ('-d', '--change-dir', {'action': 'store_true', 'dest': 'chdir', 'default': False, 'help': "change Coda's working directory"}),
    ('--ls-tabs', {'action': 'store_true', 'dest': 'lstabs', 'default': False, 'help': 'show all open tabs'}),
    ('--version', {'action': 'store_true', 'default': False, 'help': 'print version information and quit'}),
)
for opt in opts:
    parser.add_option(*opt[:-1], **opt[-1])
parser.version = "%%prog: %s" % version

(options, files) = parser.parse_args()

def open_tabs():
    scpt =  """
            set AppleScript's text item delimiters to "\n"
            tell application "Coda"
                return (file path of every editor of every split of every tab of every document as text)
            end tell
            """
    tabs = commands.getoutput("osascript<<END\n%s\nEND\n:" % scpt)
    return [os.path.realpath(tab) for tab in filter(lambda a: a != "missing value", tabs.rstrip("\n").split("\n"))]

if options.version:
    parser.print_version()
    exit()

if options.lstabs:
    print "\n".join(open_tabs())
    exit()

from_stdin = (files == ['-'] or not sys.stdin.isatty())
to_stdout  = (not sys.stdout.isatty())
tempfile   = None

if not files and not to_stdout:
    os.system('open -b %s' % bundle_id)
    exit()

if from_stdin or to_stdout:
    (fd, tempfile) = mkstemp(prefix='coda ')
    options.wait = True
    files = [tempfile]

if from_stdin: # could this be a pipe?
    if sys.stdin.isatty(): # not a pipe, wait for more stdin
        sys.stderr.write("coda: Reading from stdin... (press CTRL-D to proceed)\n")
    open(tempfile, 'w').write(sys.stdin.read())

return_to = None
if options.wait:
    return_to = commands.getoutput('osascript -e "tell application \\"System Events\\" to return name of first application process whose frontmost is true"')

files = [os.path.realpath(f) for f in files]

for name in files:
    if not os.path.exists(name):
        os.system('mkdir -p %s' % quote(os.path.dirname(name)))
        os.system('touch %s' % quote(name))
    os.system('open -b %s %s' % (bundle_id, quote(name)))

if options.chdir:
    plen = len(os.path.commonprefix(files))
    path = os.path.commonprefix([f[:plen].rsplit("/", 1)[0] for f in files])
    if not os.path.isdir(path):
        path = os.path.dirname(path)
    os.system('open -b %s %s' % (bundle_id, quote(path)))

if options.wait:
    while list(set(files) & set(open_tabs())):
        time.sleep(.5)
    if to_stdout:
        sys.stdout.write(open(tempfile).read())
    elif tempfile:
        sys.stderr.write("File written to %s" % quote(tempfile))
    if return_to:
        os.system('osascript -e "tell application \\"%s\\" to activate"' % return_to)
